#!/usr/bin/env python3
"""
NPM Helper CLI Tool

Provides administrative commands for managing Nginx Proxy Manager:
- show-admin: Display current admin credentials
- rotate-admin: Generate and set a new admin password
- status: Show system and service status
"""

import argparse
import json
import os
import subprocess
import sys
import time
import shutil
from pathlib import Path

# Import shared utilities
from npm_common import (
    wait_for_db,
    get_sqlite_connection,
    generate_password,
    hash_password,
    get_admin_user_id,
    set_admin_password,
    write_credentials_file,
    detect_instance_ip,
    build_motd_script,
    AdminUserNotFoundError,
    AuthRecordNotFoundError,
    DatabaseTimeoutError,
    ADMIN_EMAIL,  # Configurable via NPM_ADMIN_EMAIL env var
)

# Shared constants
DB_PATH = "/opt/npm/data/database.sqlite"
CREDENTIALS_PATH = "/root/npm-admin-credentials.txt"
MOTD_PATH = "/etc/update-motd.d/50-npm-info"
BACKUP_DIR = "/var/backups"

# Backup status sentinel files
BACKUP_STATE_DIR = "/var/lib/northstar/npm"
SENTINEL_LAST_RUN = f"{BACKUP_STATE_DIR}/backup-last-run"
SENTINEL_LAST_SUCCESS = f"{BACKUP_STATE_DIR}/backup-last-success"
SENTINEL_LAST_FAILURE = f"{BACKUP_STATE_DIR}/backup-last-failure"

# First-boot status files
PREFLIGHT_STATUS = f"{BACKUP_STATE_DIR}/preflight-status"
POSTINIT_STATUS = f"{BACKUP_STATE_DIR}/postinit-status"
INIT_MARKER_FILE = "/var/lib/npm-init-complete"

def require_root(action_name: str) -> None:
    if os.geteuid() != 0:
        print(f"Error: '{action_name}' requires root privileges.")
        print(f"Run: sudo npm-helper {action_name}")
        sys.exit(1)


def run_cmd(cmd, *, cwd=None, timeout=60, check=False):
    return subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        timeout=timeout,
        check=check,
    )


def cmd_update_os():
    """
    Run a one-click OS package upgrade (manual, opt-in).
    """
    require_root("update-os")

    start = time.time()
    print("WARNING: This will apply Ubuntu package updates and may require a reboot.")
    print("         Review changes and run during a maintenance window when possible.")
    print("")

    env = os.environ.copy()
    env["DEBIAN_FRONTEND"] = "noninteractive"

    try:
        print("Running: apt-get update")
        subprocess.run(["apt-get", "update"], env=env, check=True)

        print("")
        print("Running: apt-get upgrade -y --with-new-pkgs")
        subprocess.run(["apt-get", "upgrade", "-y", "--with-new-pkgs"], env=env, check=True)

    except subprocess.CalledProcessError as e:
        duration = int(time.time() - start)
        print(f"NORTHSTAR_UPDATE_OS status=failure duration_s={duration}")
        sys.exit(e.returncode if e.returncode != 0 else 1)

    duration = int(time.time() - start)

    if Path("/var/run/reboot-required").exists():
        print("")
        print("REBOOT REQUIRED")

    print(f"NORTHSTAR_UPDATE_OS status=success duration_s={duration}")
    sys.exit(0)


def parse_status_line(line: str):
    """
    Parse status files written by preflight/postinit scripts.
    Expected formats:
      OK <timestamp>
      FAIL <timestamp> reason=<enum>
    """
    if not line:
        return None
    parts = line.split()
    if len(parts) >= 2 and parts[0] in ("OK", "FAIL"):
        status = "ok" if parts[0] == "OK" else "fail"
        ts = parts[1]
        reason = None
        for p in parts[2:]:
            if p.startswith("reason="):
                reason = p.split("=", 1)[1]
                break
        out = {"status": status, "timestamp": ts}
        if reason:
            out["reason"] = reason
        return out
    return {"raw": line}


def systemd_unit_status(unit: str, errors: list):
    info = {"unit": unit}
    try:
        r_active = run_cmd(["systemctl", "is-active", unit], timeout=5)
        info["active"] = r_active.stdout.strip() if r_active.stdout.strip() else "unknown"
        r_enabled = run_cmd(["systemctl", "is-enabled", unit], timeout=5)
        info["enabled"] = r_enabled.stdout.strip() if r_enabled.stdout.strip() else "unknown"
    except FileNotFoundError:
        errors.append(f"systemctl_not_found:{unit}")
        info["active"] = "unknown"
        info["enabled"] = "unknown"
    except Exception as e:
        errors.append(f"systemctl_error:{unit}:{type(e).__name__}")
        info["active"] = "unknown"
        info["enabled"] = "unknown"
    return info


def cmd_diagnostics(json_mode: bool = False):
    """
    Gather non-sensitive diagnostics for support and troubleshooting.
    """
    errors = []
    core_errors = []

    # Lifecycle markers
    preflight = parse_status_line(read_sentinel_file(PREFLIGHT_STATUS))
    postinit = parse_status_line(read_sentinel_file(POSTINIT_STATUS))
    init_marker = Path(INIT_MARKER_FILE)
    init_info = {"status": "complete" if init_marker.exists() else "incomplete"}
    if init_marker.exists():
        try:
            init_info["timestamp"] = time.strftime("%Y-%m-%dT%H:%M:%S%z", time.localtime(init_marker.stat().st_mtime))
        except Exception:
            pass

    # Systemd statuses (core)
    units = [
        "npm.service",
        "npm-preflight.service",
        "npm-init.service",
        "npm-postinit.service",
        "npm-backup.timer",
        "npm-backup.service",
    ]
    unit_statuses = []
    for u in units:
        st = systemd_unit_status(u, errors)
        unit_statuses.append(st)
        if st.get("active") == "unknown" and st.get("enabled") == "unknown":
            core_errors.append(f"systemd_status_unavailable:{u}")

    # Disk usage (core)
    disk = {}
    try:
        du_root = shutil.disk_usage("/")
        disk["root"] = {
            "path": "/",
            "total_bytes": du_root.total,
            "used_bytes": du_root.used,
            "free_bytes": du_root.free,
            "used_percent": round((du_root.used / du_root.total) * 100, 2) if du_root.total else None,
        }
    except Exception as e:
        core_errors.append(f"disk_usage_error_root:{type(e).__name__}")

    try:
        du_backups = shutil.disk_usage(BACKUP_DIR)
        disk["backups"] = {
            "path": BACKUP_DIR,
            "total_bytes": du_backups.total,
            "used_bytes": du_backups.used,
            "free_bytes": du_backups.free,
            "used_percent": round((du_backups.used / du_backups.total) * 100, 2) if du_backups.total else None,
        }
    except FileNotFoundError:
        disk["backups"] = {"path": BACKUP_DIR, "error": "not_found"}
    except Exception as e:
        errors.append(f"disk_usage_error_backups:{type(e).__name__}")

    # CloudWatch agent status (best-effort)
    cw = {"service": "amazon-cloudwatch-agent.service"}
    cw.update(systemd_unit_status("amazon-cloudwatch-agent.service", errors))

    # IAM availability (best-effort, no AWS SDK; IMDSv2 attempt with short timeouts)
    iam = {"available": "unknown", "method": "imds"}
    try:
        if not shutil.which("curl"):
            raise FileNotFoundError()
        # token
        token = run_cmd(
            ["curl", "-sS", "-m", "1", "-X", "PUT", "http://169.254.169.254/latest/api/token",
             "-H", "X-aws-ec2-metadata-token-ttl-seconds: 60"],
            timeout=2,
        )
        if token.returncode == 0 and token.stdout.strip():
            t = token.stdout.strip()
            role = run_cmd(
                ["curl", "-sS", "-m", "1", "-H", f"X-aws-ec2-metadata-token: {t}",
                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/"],
                timeout=2,
            )
            iam["available"] = bool(role.returncode == 0 and role.stdout.strip())
        else:
            iam["available"] = "unknown"
    except FileNotFoundError:
        iam["available"] = "unknown"
    except Exception:
        iam["available"] = "unknown"

    # NPM container health (best-effort)
    npm_container = {"status": "unknown", "containers": []}
    try:
        r = run_cmd(["docker", "compose", "ps", "--format", "json"], cwd="/opt/npm", timeout=5)
        if r.returncode == 0 and r.stdout.strip():
            for line in r.stdout.strip().splitlines():
                line = line.strip()
                if not line:
                    continue
                try:
                    obj = json.loads(line)
                    npm_container["containers"].append(
                        {
                            "name": obj.get("Name"),
                            "service": obj.get("Service"),
                            "state": obj.get("State"),
                            "health": obj.get("Health"),
                        }
                    )
                except Exception:
                    continue
            # derive overall status
            if any(c.get("state") == "running" for c in npm_container["containers"]):
                npm_container["status"] = "running"
            elif npm_container["containers"]:
                npm_container["status"] = "not_running"
            else:
                npm_container["status"] = "unknown"
        else:
            npm_container["status"] = "not_found"
    except FileNotFoundError:
        npm_container["status"] = "docker_not_found"
    except Exception as e:
        errors.append(f"docker_compose_ps_error:{type(e).__name__}")

    result = {
        "product": "Nginx Proxy Manager â€“ Hardened Edition AMI",
        "vendor": "Northstar Cloud Solutions LLC",
        "lifecycle": {
            "preflight": preflight,
            "init": init_info,
            "postinit": postinit,
        },
        "systemd": {"units": unit_statuses},
        "disk": disk,
        "cloudwatch": {"agent": cw, "iam_available": iam["available"], "iam_method": iam["method"]},
        "npm": npm_container,
        "errors": errors,
    }

    exit_code = 0
    if core_errors:
        result.setdefault("errors", []).extend(core_errors)
        exit_code = 1

    if json_mode:
        sys.stdout.write(json.dumps(result, separators=(",", ":"), sort_keys=True) + "\n")
        sys.exit(exit_code)

    # Human output (keep concise)
    print("NPM Diagnostics")
    print("=" * 50)
    print(f"Init: {init_info.get('status')}")
    if preflight:
        print(f"Preflight: {preflight}")
    if postinit:
        print(f"Post-init: {postinit}")
    print("")
    for u in unit_statuses:
        print(f"{u['unit']}: active={u.get('active')} enabled={u.get('enabled')}")
    if disk.get("root"):
        print(f"Disk / used_percent={disk['root'].get('used_percent')}%")
    if disk.get("backups") and isinstance(disk["backups"], dict) and disk["backups"].get("used_percent") is not None:
        print(f"Disk {BACKUP_DIR} used_percent={disk['backups'].get('used_percent')}%")
    print(f"CloudWatch agent active={cw.get('active')} enabled={cw.get('enabled')} iam_available={iam.get('available')}")
    print(f"NPM containers status={npm_container.get('status')}")
    if errors:
        print("Errors:")
        for e in errors:
            print(f" - {e}")
    sys.exit(exit_code)


def cmd_show_admin():
    """
    Display the current admin credentials from the credentials file.
    
    Exits with code 1 if credentials file does not exist.
    """
    cred_file = Path(CREDENTIALS_PATH)
    
    if not cred_file.exists():
        print("Error: Credentials file not found.")
        print("Did npm-init run yet?")
        sys.exit(1)
    
    try:
        with open(cred_file, 'r') as f:
            lines = f.readlines()
        
        username = None
        password = None
        
        for line in lines:
            line = line.strip()
            if line.startswith("Username:"):
                username = line.split(":", 1)[1].strip()
            elif line.startswith("Password:"):
                password = line.split(":", 1)[1].strip()
        
        if not username or not password:
            print("Error: Could not parse credentials file.")
            sys.exit(1)
        
        print(f"Admin user: {username}")
        print("Admin password: (not displayed)")
        print("For security, the password is only shown on first login (MOTD).")
        
    except Exception as e:
        print(f"Error reading credentials file: {e}")
        sys.exit(1)


def cmd_rotate_admin():
    """
    Generate a new admin password and update the database, credentials file, and MOTD.
    
    Exits with code 1 on errors (database timeout, user not found, etc.).
    """
    print("Rotating admin password...")
    
    # Wait for database to be ready
    try:
        print(f"Waiting for database at {DB_PATH}...")
        wait_for_db(DB_PATH)
        print("Database is ready.")
    except DatabaseTimeoutError as e:
        print(f"Error: {e}")
        sys.exit(1)
    
    # Get database connection
    try:
        conn = get_sqlite_connection(DB_PATH)
    except Exception as e:
        print(f"Error connecting to database: {e}")
        sys.exit(1)
    
    try:
        # Look up admin user
        try:
            user_id = get_admin_user_id(conn, ADMIN_EMAIL)
            print(f"Found admin user with ID: {user_id}")
        except AdminUserNotFoundError as e:
            print(f"Error: {e}")
            conn.close()
            sys.exit(1)
        
        # Generate new password
        new_password = generate_password()
        print("Generated new admin password.")
        
        # Hash the password
        password_hash = hash_password(new_password)
        
        # Update password in database
        try:
            set_admin_password(conn, user_id, password_hash)
            print("Password updated in database.")
        except AuthRecordNotFoundError as e:
            print(f"Error: {e}")
            conn.close()
            sys.exit(1)
        
        # Write credentials file
        try:
            write_credentials_file(CREDENTIALS_PATH, ADMIN_EMAIL, new_password)
            print("Credentials written to root-only credentials file.")
        except Exception as e:
            print(f"Error writing credentials file: {e}")
            conn.close()
            sys.exit(1)
        
        # Detect IP and update MOTD
        try:
            ip = detect_instance_ip()
            print(f"Detected instance IP: {ip}")
            
            motd_content = build_motd_script(ip, ADMIN_EMAIL, new_password)
            
            with open(MOTD_PATH, 'w') as f:
                f.write(motd_content)
            
            # Make MOTD script executable
            os.chmod(MOTD_PATH, 0o755)
            print(f"MOTD script updated at {MOTD_PATH}")
            
        except Exception as e:
            print(f"Warning: Failed to update MOTD: {e}")
            # Don't exit on MOTD failure, password rotation succeeded
        
        conn.close()
        
        print("\nPassword rotation completed successfully!")
        print(f"Admin user: {ADMIN_EMAIL}")
        print("New password: (not displayed)")
        
    except Exception as e:
        print(f"Unexpected error during password rotation: {e}")
        conn.close()
        sys.exit(1)


def read_sentinel_file(filepath: str) -> str:
    """
    Read the contents of a sentinel file.
    
    Args:
        filepath: Path to the sentinel file
    
    Returns:
        Contents of the file, or None if file doesn't exist or is unreadable
    """
    try:
        sentinel = Path(filepath)
        if sentinel.exists() and sentinel.is_file():
            return sentinel.read_text().strip()
    except Exception:
        pass
    return None


def cmd_status():
    """
    Display system and service status.
    
    Shows:
    - Docker service status
    - npm service status
    - NPM container status
    - Backup status (last run, last success, last failure)
    
    Exits with code 0 unless an unexpected error occurs.
    """
    status_info = {}
    
    # Check Docker service status
    try:
        result = subprocess.run(
            ["systemctl", "is-active", "docker"],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            status_info["docker"] = result.stdout.strip()
        else:
            status_info["docker"] = "inactive"
    except Exception as e:
        status_info["docker"] = f"unknown (error: {e})"
    
    # Check npm service status
    try:
        result = subprocess.run(
            ["systemctl", "is-active", "npm"],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            status_info["npm"] = result.stdout.strip()
        else:
            status_info["npm"] = "inactive"
    except Exception as e:
        status_info["npm"] = f"unknown (error: {e})"
    
    # Check NPM container status
    container_status = "unknown"
    try:
        result = subprocess.run(
            ["docker", "compose", "ps", "--format", "json"],
            cwd="/opt/npm",
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode == 0 and result.stdout.strip():
            # Parse JSON output to determine container state
            import json
            lines = result.stdout.strip().split('\n')
            for line in lines:
                if line.strip():
                    try:
                        container = json.loads(line)
                        state = container.get("State", "unknown")
                        if state == "running":
                            container_status = "running"
                            break
                        elif state in ["exited", "stopped"]:
                            container_status = "exited"
                    except json.JSONDecodeError:
                        pass
        else:
            container_status = "not found"
    except FileNotFoundError:
        container_status = "docker compose not available"
    except Exception as e:
        container_status = f"error checking ({e})"
    
    status_info["container"] = container_status
    
    # Find last backup file
    last_backup_file = "none found"
    try:
        backup_dir = Path(BACKUP_DIR)
        if backup_dir.exists() and backup_dir.is_dir():
            backup_files = list(backup_dir.glob("npm-*.tar.gz"))
            if backup_files:
                # Sort by modification time, most recent first
                backup_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
                last_backup_file = backup_files[0].name
    except Exception as e:
        last_backup_file = f"error checking ({e})"
    
    # Read backup status from sentinel files
    backup_last_run = read_sentinel_file(SENTINEL_LAST_RUN)
    backup_last_success = read_sentinel_file(SENTINEL_LAST_SUCCESS)
    backup_last_failure = read_sentinel_file(SENTINEL_LAST_FAILURE)

    # Read first-boot status
    preflight_status = read_sentinel_file(PREFLIGHT_STATUS)
    postinit_status = read_sentinel_file(POSTINIT_STATUS)
    init_complete = Path(INIT_MARKER_FILE).exists()
    
    # Print status summary
    print("NPM System Status")
    print("=" * 50)
    print(f"Docker service:   {status_info['docker']}")
    print(f"npm service:      {status_info['npm']}")
    print(f"NPM container:    {status_info['container']}")
    print("=" * 50)
    print("")
    print("Initialization Status")
    print("-" * 50)
    if preflight_status:
        print(f"Preflight:       {preflight_status}")
    else:
        print("Preflight:       not yet run")
    print(f"Init:            {'complete' if init_complete else 'incomplete'}")
    if postinit_status:
        print(f"Post-init:       {postinit_status}")
    else:
        print("Post-init:       not yet run")
    print("-" * 50)

    print("")
    print("Backup Status")
    print("-" * 50)
    print(f"Last backup file: {last_backup_file}")
    
    if backup_last_run:
        print(f"Last run:         {backup_last_run}")
    else:
        print("Last run:         never")
    
    if backup_last_success:
        print(f"Last success:     {backup_last_success}")
    else:
        print("Last success:     none")
    
    if backup_last_failure:
        print(f"Last failure:     {backup_last_failure}")
    
    print("-" * 50)


def main():
    """Main entry point for npm-helper CLI."""
    parser = argparse.ArgumentParser(
        description="NPM Helper - Administrative commands for Nginx Proxy Manager",
        prog="npm-helper"
    )
    
    subparsers = parser.add_subparsers(
        dest="command",
        help="Available commands",
        required=True
    )
    
    # show-admin subcommand
    parser_show = subparsers.add_parser(
        "show-admin",
        help="Display current admin credentials"
    )
    
    # rotate-admin subcommand
    parser_rotate = subparsers.add_parser(
        "rotate-admin",
        help="Generate and set a new admin password"
    )
    
    # status subcommand
    parser_status = subparsers.add_parser(
        "status",
        help="Show system and service status"
    )

    # update-os subcommand
    subparsers.add_parser("update-os", help="Run a one-click OS update (apt-get update && apt-get upgrade)")

    # diagnostics subcommand
    parser_diag = subparsers.add_parser("diagnostics", help="Collect non-sensitive diagnostics for troubleshooting")
    parser_diag.add_argument(
        "--json",
        action="store_true",
        help="Output machine-readable JSON only"
    )
    
    # Parse arguments
    args = parser.parse_args()
    
    # Execute the appropriate command
    if args.command == "show-admin":
        cmd_show_admin()
    elif args.command == "rotate-admin":
        cmd_rotate_admin()
    elif args.command == "status":
        cmd_status()
    elif args.command == "update-os":
        cmd_update_os()
    elif args.command == "diagnostics":
        cmd_diagnostics(json_mode=getattr(args, "json", False))
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()

